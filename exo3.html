<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Exo 2 - Contrôle de la Caméra et Zoom</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
      html, body { margin: 0; height: 100%; background: #000; }
      .hint {
        position: fixed; left: 12px; bottom: 12px;
        padding: 8px 12px;
        background: rgba(0,0,0,.55);
        color: #fff;
        font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        border-radius: 8px;
      }
      .hint kbd{ padding:2px 6px; border:1px solid #888; border-bottom-width:2px; border-radius:4px; background:#111 }
    </style>
  </head>
  <body>

    <a-scene renderer="colorManagement: true; physicallyCorrectLights: true">
      <a-assets>
        <img id="grass" src="assets/grass.jpg" crossorigin="anonymous" />
        <img id="sky360" src="assets/sky.jpg" crossorigin="anonymous" />
      </a-assets>

      <a-sky src="#sky360" radius="5000"></a-sky>
      <a-entity light="type: ambient; intensity: 0.45"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="0 5 5"></a-entity>

      <a-plane id="ground" rotation="-90 0 0" width="200" height="200"
                material="src: #grass; repeat: 50 50; roughness: 1; metalness: 0; side: double"></a-plane>

      <a-entity id="player"
                geometry="primitive: box; width: 1; height: 1; depth: 1"
                material="color: #4cc3d9; metalness: 0; roughness: 1"
                position="0 0 0"
                player-controller="groundY: 0; accel: 20; maxSpeed: 8; decel: 14; gravity: 25; jumpSpeed: 8">
      </a-entity>

      <a-entity id="camera-pivot" mouse-orbit-camera="minZoom: 3; maxZoom: 20; initialZoom: 8">
        <a-entity id="third-person-camera"
                  camera="active: true"
                  position="0 2 8"
                  look-at="#player">
        </a-entity>
      </a-entity>
    </a-scene>

    <div class="hint">Utilise
      <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> ou <kbd>Z</kbd> <kbd>Q</kbd> <kbd>S</kbd> <kbd>D</kbd>
      pour se déplacer et <kbd>ESPACE</kbd> pour sauter. Clique et déplace la souris pour faire pivoter la caméra. Utilise la molette de la souris pour zoomer.</div>

    <script>
      // Composant pour le contrôle du joueur (mouvement et saut)
      AFRAME.registerComponent('player-controller', {
        schema: {
          groundY: { type: 'number', default: 0 },
          accel:   { type: 'number', default: 20 },
          maxSpeed:{ type: 'number', default: 8 },
          decel:   { type: 'number', default: 14 },
          gravity: { type: 'number', default: 25 },
          jumpSpeed:{type: 'number', default: 8 }
        },
        init: function () {
          this.vel = new THREE.Vector3();
          this.input = { f:false, b:false, l:false, r:false, jump:false };
          this.grounded = false;
          this.halfH = 0.5;
          this.computeHalfHeight();
          const p = this.el.object3D.position;
          p.y = this.data.groundY + this.halfH;
          this.onKeyDown = this.onKeyDown.bind(this);
          this.onKeyUp = this.onKeyUp.bind(this);
          window.addEventListener('keydown', this.onKeyDown);
          window.addEventListener('keyup',   this.onKeyUp);
        },
        remove: function(){
          window.removeEventListener('keydown', this.onKeyDown);
          window.removeEventListener('keyup',   this.onKeyUp);
        },
        computeHalfHeight: function(){
          const g = this.el.getAttribute('geometry');
          if (g && g.primitive === 'box') {
            const h = (parseFloat(g.height) || 1);
            this.halfH = h * 0.5;
          } else {
            const box = new THREE.Box3().setFromObject(this.el.object3D);
            const size = new THREE.Vector3();
            box.getSize(size);
            this.halfH = size.y * 0.5 || 0.5;
          }
        },
        onKeyDown: function(e){
          const k = (e.key || '').toLowerCase();
          if (k === 'w' || k === 'z') this.input.f = true;
          if (k === 's')             this.input.b = true;
          if (k === 'a' || k === 'q') this.input.l = true;
          if (k === 'd')             this.input.r = true;
          if (k === ' ')             this.input.jump = true;
        },
        onKeyUp: function(e){
          const k = (e.key || '').toLowerCase();
          if (k === 'w' || k === 'z') this.input.f = false;
          if (k === 's')             this.input.b = false;
          if (k === 'a' || k === 'q') this.input.l = false;
          if (k === 'd')             this.input.r = false;
          if (k === ' ')             this.input.jump = false;
        },
        tick: function (time, dt) {
          if (!dt) return;
          dt = dt / 1000;
          const data = this.data;
          const pos = this.el.object3D.position;
          const vel = this.vel;
          const pivotEl = document.getElementById('camera-pivot');
          const pivotRot = pivotEl.object3D.rotation.y;
          const forwardVec = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), pivotRot);
          const rightVec = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), pivotRot);
          let wish = new THREE.Vector3();
          if (this.input.f) wish.add(forwardVec);
          if (this.input.b) wish.sub(forwardVec);
          if (this.input.r) wish.add(rightVec);
          if (this.input.l) wish.sub(rightVec);
          if (wish.lengthSq() > 0) {
            wish.normalize().multiplyScalar(data.maxSpeed);
            this.approach(vel, wish, data.accel * dt);
          } else {
            this.applyDecel(vel, data.decel * dt);
          }
          const groundLevel = data.groundY + this.halfH;
          const onGround = (pos.y <= groundLevel + 1e-4);
          this.grounded = onGround;
          if (onGround) {
            pos.y = groundLevel;
            if (vel.y < 0) vel.y = 0;
            if (this.input.jump) {
              vel.y = data.jumpSpeed;
            }
          } else {
            vel.y -= data.gravity * dt;
          }
          pos.x += vel.x * dt;
          pos.y += vel.y * dt;
          pos.z += vel.z * dt;
          if (pos.y < groundLevel) {
            pos.y = groundLevel;
            if (vel.y < 0) vel.y = 0;
            this.grounded = true;
          }
          pivotEl.object3D.position.copy(pos);
        },
        approach: function(vel, wish, step){
          const dx = wish.x - vel.x;
          if (Math.abs(dx) > step) vel.x += step * Math.sign(dx); else vel.x = wish.x;
          const dz = wish.z - vel.z;
          if (Math.abs(dz) > step) vel.z += step * Math.sign(dz); else vel.z = wish.z;
        },
        applyDecel: function(vel, step){
          if (Math.abs(vel.x) <= step) vel.x = 0; else vel.x -= step * Math.sign(vel.x);
          if (Math.abs(vel.z) <= step) vel.z = 0; else vel.z -= step * Math.sign(vel.z);
        }
      });
      
      // Composant pour le contrôle de l'orbite et le zoom de la caméra avec la souris
      AFRAME.registerComponent('mouse-orbit-camera', {
        schema: {
          minZoom: { type: 'number', default: 1 },
          maxZoom: { type: 'number', default: 20 },
          initialZoom: { type: 'number', default: 8 }
        },
        init: function () {
          this.isDragging = false;
          this.lastMouseX = 0;
          this.lastMouseY = 0;
          
          this.minPitch = -15 * Math.PI / 180; // -15 degrés en radians
          this.maxPitch = 45 * Math.PI / 180;  // 45 degrés en radians

          this.currentZoom = this.data.initialZoom; // Initialisation du zoom

          // Définir la position initiale de la caméra en fonction du zoom
          const cameraEl = this.el.querySelector('#third-person-camera');
          if (cameraEl) {
            cameraEl.object3D.position.z = this.currentZoom; // Utilise le zoom comme distance sur Z
          }

          this.onMouseDown = this.onMouseDown.bind(this);
          this.onMouseUp = this.onMouseUp.bind(this);
          this.onMouseMove = this.onMouseMove.bind(this);
          this.onMouseWheel = this.onMouseWheel.bind(this);

          this.el.sceneEl.addEventListener('mousedown', this.onMouseDown);
          this.el.sceneEl.addEventListener('mouseup', this.onMouseUp);
          this.el.sceneEl.addEventListener('mousemove', this.onMouseMove);
          this.el.sceneEl.addEventListener('wheel', this.onMouseWheel); // Écoute l'événement de la molette
        },

        remove: function() {
          this.el.sceneEl.removeEventListener('mousedown', this.onMouseDown);
          this.el.sceneEl.removeEventListener('mouseup', this.onMouseUp);
          this.el.sceneEl.removeEventListener('mousemove', this.onMouseMove);
          this.el.sceneEl.removeEventListener('wheel', this.onMouseWheel);
        },

        onMouseDown: function(evt) {
          this.isDragging = true;
          this.lastMouseX = evt.clientX;
          this.lastMouseY = evt.clientY;
        },

        onMouseUp: function() {
          this.isDragging = false;
        },

        onMouseMove: function(evt) {
          if (!this.isDragging) return;
          
          const deltaX = evt.clientX - this.lastMouseX;
          const deltaY = evt.clientY - this.lastMouseY;

          // Rotation horizontale (Yaw) du pivot
          this.el.object3D.rotation.y -= deltaX * 0.005;

          // Rotation verticale (Pitch) de la caméra elle-même
          const cameraEl = this.el.querySelector('#third-person-camera');
          if (cameraEl) {
            let newPitch = cameraEl.object3D.rotation.x - deltaY * 0.005;
            newPitch = Math.max(this.minPitch, Math.min(this.maxPitch, newPitch));
            cameraEl.object3D.rotation.x = newPitch;
          }

          this.lastMouseX = evt.clientX;
          this.lastMouseY = evt.clientY;
        },

        onMouseWheel: function(evt) {
          evt.preventDefault(); // Empêche le défilement de la page
          
          const zoomSpeed = 0.5; // Vitesse de zoom

          // Détection de la direction de la molette
          if (evt.deltaY > 0) { // Molette vers le bas (dézoomer)
            this.currentZoom = Math.min(this.data.maxZoom, this.currentZoom + zoomSpeed);
          } else { // Molette vers le haut (zoomer)
            this.currentZoom = Math.max(this.data.minZoom, this.currentZoom - zoomSpeed);
          }

          // Appliquer le nouveau zoom à la position Z de la caméra
          const cameraEl = this.el.querySelector('#third-person-camera');
          if (cameraEl) {
            cameraEl.object3D.position.z = this.currentZoom;
          }
        }
      });
    </script>
  </body>
</html>